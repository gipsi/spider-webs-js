
<!doctype html>
<html>
	<head>
		<title>JS1k, 1k demo submission [ID]</title>
		<meta charset="utf-8" />
	</head>
	<body>
		<canvas id="c"></canvas>
		<script>
			var b = document.body;
			var c = document.getElementsByTagName('canvas')[0];
			var a = c.getContext('2d');
			document.body.clientWidth; // fix bug in webkit: http://qfox.nl/weblog/218
		</script>
		<script>
// start of submission //
c.width = 800;
c.height = 800;
function P(x,y){
	this.x = x;
	this.y = y;
}
	
function web(){
	with(document){
		// define the anchor points of the heart shape
		var rays, raySpacing, spacingNoise, strandNoise, pointNum, centerX, centerY, barPtAmt, radiusBase, anchors, barPointAmt;
		var p = [10, 10, 10, 100, 100, 100, 100, 10];
		
		pointNum = 5;
		raySpacing = (Math.random() * 30) + 40;
		barPointAmt = (Math.random() * 10) + 15;
		var particles = new Array();
		var strands = new Array();
		var centerX = 250;
		var centerY = 250;
		radiusBase = 200;
		
		// draw the anchors
		
		
		a.lineWidth = 1;
		a.beginPath();
		a.moveTo(0, 0);
		a.lineTo(100, 75);
		a.lineTo(100, 25);
		a.closePath();
		a.stroke();
		
		// make points for "love"
		// draw lines along the points for each letter
		
		
		drawWeb = function()
		{
			var i, s, strand;
			strands = new Array();
			rays = new Array();
			
			spacingNoise = Math.random()*10;
		        strandNoise = Math.random()*100;
			
			// draw everything
		        this.placeAnchorPoints();
		        this.drawPerimeterLines();
		};
		
		
		placeAnchorPoints = function()
		{
			var anchorPoints, angleDif, maxX, minX, maxY, minY, radiusSum, i, angle, r, pX, pY, p, startPt, endPt, anchor;
			anchorPoints = new Array();
			angleDif = (Math.PI * 2)/pointNum;
			maxX = 0;
			minX = 500;
			maxY = 0;
			minY = 500;
			radiusSum = 0;
			
			var p = new P(100, 100);
			console.log(p.x);
			
			console.log(pointNum);
			for (i=0; i<pointNum; i+=1) {
				angle = (i * angleDif);
				r = radiusBase * (Math.random() + 0.5);
				radiusSum += r;
				pX = centerX + Math.cos(angle) * r;
				pY = centerY + Math.sin(angle) * r;
				p = this.addParticle(pX, pY);
			      
				maxX = (pX > maxX) ? pX : maxX;
				minX = (pX < minX) ? pX : minX;
				maxY = (pY > maxY) ? pY : maxY;
				minY = (pY < minY) ? pY : minY;
			    
				anchorPoints.push(p);
			}
    
			avgRadius = radiusSum / pointNum;
			webCenter = this.addParticle(minX + (maxX - minX)/2, minY + (maxY - minY)/2);
		      
			// create the anchor strands from the points
			this.anchors = new Array();
			for (i=0; i<anchorPoints.length; i+=1) {
			  startPt = anchorPoints[i];
			  endPt = (i<anchorPoints.length-1) ? anchorPoints[i+1] : anchorPoints[0];
			  anchor = new Anchor(i, startPt, endPt);
			  anchor.drawEdgeLines();
			  
			  this.anchors.push(anchor);
			}
		};
		
		
		// draw the lines between the anchor points
		drawPerimeterLines = function() {
		    var i, anchor;
		    console.log(this.anchors.length);
		    for (i=0; i<this.anchors.length; i+=1) {
			anchor = this.anchors[i];
			anchor.makePoints();
		    }
		  
		    for (i=0; i<anchors.length; i+=1) {
			anchor = anchors[i];
			//anchor.defineSourceLines();
		    }
		    this.makeRays();
		};
		
    
		makeRays = function() {
			console.log("make rays");
			var i, r;
			for (i=0; i<rays.length; i+=1)
			{
			  r = rays[i];
			  r.make();
			}
		      
			for (i=0; i<rays.length; i+=1)
			{
			  r = rays[i];
			  r.defineRayPoints();
			}
		};
		
		
		addParticle = function(xPos,yPos)
		{
			var pt, i;
			// first check to see if a particle of the same position is already there. Return it if so.
			for(i=0; i<particles.length; i+=2){
			    if(particles[i].x === xPos && particles[i].y === yPos){
				return particles[i];
			    }
			}
			pt = new P(xPos, yPos);
			particles.push(pt);
			
			return pt;
		};
		
		
		
		
		/*******************************
     
				ANCHOR
     
		******************************* */

		function Anchor(theOrder, theStartPoint, theEndPoint) {
		    var dx, dy, dif;
		    
		    this.startPt = new P(theStartPoint.x, theStartPoint.y);	// start point of the connecting line
		    this.endPt = new P(theEndPoint.x, theEndPoint.y);		// end point of the connecting line
		    this.pointSpacing = raySpacing;							// amount of space between strands (35 is good). This may have to depend on other things later such as the average line length or something.
		    this.myOrder = theOrder;						// order of the point within all radial points
		    this.myAngle = undefined;						// angle of this strand (towards the web center)
		    this.nextAngle = undefined;						// angle of the next strand
		    this.webCenterPoint = new P(webCenter.x, webCenter.y);	// vector of the web center particle
		    this.randomLinePoints = [];						// additional random line points along the same anchor to edge line
		    this.rayPoints = [];							// points to connect the ray
		  
		    this.startPoint = theStartPoint;
		    this.nextPoint = theEndPoint;
		    this.edgePoint = undefined;
		    
		    // find the angle of the anchor point (in relation to the web center)
		    dx = (this.startPt.x - this.webCenterPoint.x);
		    dy = (this.startPt.y - this.webCenterPoint.y);
		    dif = a.width  - Math.sqrt(dx*dx + dy*dy);
		    this.myAngle = Math.atan2(dy, dx);
		    
		    dx = (this.endPt.x - this.webCenterPoint.x);
		    dy = (this.endPt.y - this.webCenterPoint.y);
		    dif = a.width  - Math.sqrt(dx*dx + dy*dy);
		    this.nextAngle = Math.atan2(dy, dx);
		}





		// draw the lines from the anchor points to the border
		Anchor.prototype.drawEdgeLines = function()
		{
		    var pointAmt, opAngle, sideDistX, sideDistY, opRx, opRy, opR, lenFactor, i,randLen, midPoint, curP, prevP, pDist;
		    // randomly find a random amount of points to place between the start and end point
		    pointAmt = Math.round(Math.random()) === 0 ? Math.round(Math.random()*7 + 1) : 1;
		    
		    this.randomLinePoints = [];
		    this.randomLinePoints[0] = this.startPoint;
		
		    opAngle = Math.PI/2 - ((this.myAngle < 0) ? this.myAngle + Math.PI*2: this.myAngle);
		    sideDistX = (this.startPt.x < c.width/2) ? -this.startPt.x:c.width - this.startPt.x;
		    sideDistY = (this.startPt.y < c.height/2) ? -this.startPt.y : c.height - this.startPt.y;
		
		    opRx = sideDistX/Math.sin(opAngle);
		    opRy = sideDistY/Math.cos(opAngle);
		    opR =  (Math.abs(opRx)<Math.abs(opRy)) ? opRx : opRy;
		
		    this.edgePoint = addParticle(this.startPt.x +  Math.cos(this.myAngle) * (opR), this.startPt.y + Math.sin(this.myAngle) * (opR));
		
		    lenFactor = opR/pointAmt;
		    for (i=0; i<pointAmt; i+=1) {
			randLen = lenFactor * i + Math.random()*lenFactor; 
			midPoint = addParticle(this.startPt.x +  Math.cos(this.myAngle) * (randLen), this.startPt.y + Math.sin(this.myAngle) * (randLen));
			this.randomLinePoints.push(midPoint);
		    }
		
		    this.randomLinePoints[this.randomLinePoints.length] = this.edgePoint;
		    for (i=1; i<this.randomLinePoints.length; i+=1)
		    {
			curP = this.randomLinePoints[i];
			prevP = this.randomLinePoints[i-1];
			pDist = getPartDist(prevP, curP);
			addStrand(curP, prevP, pDist);   
		    }
		};

 

		Anchor.prototype.makePoints = function()
		{
			var dx, dy, lineDist, lineAngle, linePointAmt, linePointDist, pointDistFactor, halfAngle, rAngleFactor, angleDif, ctrlLen, curvePts, bezPts, i, pointX, pointY, nextT, nextX, nextY, bezP, rayPoint, r, p, nextP, t;
		    
			
					
			dx = (this.endPt.x - this.startPt.x);
			dy = (this.endPt.y - this.startPt.y);
			lineDist = Math.sqrt((dx*dx) + (dy*dy));
			lineAngle = Math.atan2(dy, dx);
			
			// ensure that there are at least 2 points to go between
			// If only 1, it will fail
			pointDistFactor = 0;
			do {
			  linePointAmt = Math.floor(lineDist/(this.pointSpacing - pointDistFactor));
			  pointDistFactor += 1;
			}
			while (linePointAmt<2);
			
			linePointDist = lineDist/linePointAmt;
			halfAngle = lineAngle + (Math.PI*2);
			rAngleFactor = Math.random() * 0.3 + 0.1;
			
			
			// make the curve more random so that it's not perfect
			angleDif = Math.PI*rAngleFactor;        // the random angle that will be sloped between points
			ctrlLen = lineDist*rAngleFactor;   // the random distance of the control points
			//a.noFill();
			/*
			// make the bezier curve points based on the calculated control factors
			curvePts = [];
			curvePts[0] = new P(this.startPt.x, this.startPt.y);
			curvePts[1] = new P(this.startPt.x + Math.cos(lineAngle+(angleDif)) * ctrlLen, this.startPt.y + Math.sin(lineAngle+(angleDif))*ctrlLen);
			curvePts[2] = new P(this.endPt.x - Math.cos(lineAngle-(angleDif)) * ctrlLen, this.endPt.y - Math.sin(lineAngle-(angleDif))*ctrlLen);
			curvePts[3] = new P(this.endPt.x, this.endPt.y);
			*/
			// Now draw the lines between bezier points
			bezPts = [];
			
			this.rayPoints = [];
			
			// make points between the start and end
			
			for (i=0; i<linePointAmt; i+=1)
			{
				t = i / linePointAmt;
				pointX = this.startPt.x + Math.cos(lineAngle) * (i*linePointDist);
				pointY = this.startPt.y + Math.sin(lineAngle) * (i*linePointDist);
				addParticle(pointX, pointY);
				
				
				
				
				var rayP = addParticle(pointX, pointY);
				r = new Ray(rays.length, rayP, webCenter, spacingNoise);
				rays.push(r);
				
				this.rayPoints.push(rayP);
				/*if (i>0)
				{
					this.rayPoints.push(rayP);
					/*
					a.beginPath();
					//a.arc(p.x, p.y, 2,0,Math.PI*2,true);
					a.arc(rayP.x, rayP.y, 2,0,Math.PI*2,true);
					if(i == 0) {a.strokeStyle = 'rgb(255, 0, 0)';
					}else{a.strokeStyle = 'rgb(0, 0, 0)'};
					a.stroke();*/
				//}
				
			    /*pointX = a.bezierPoint(curvePts[0].x, curvePts[1].x, curvePts[2].x, curvePts[3].x, t);
			    pointY = a.bezierPoint(curvePts[0].y, curvePts[1].y, curvePts[2].y, curvePts[3].y, t);
		      
			    nextT = (t<linePointAmt-1) ? (i+1) / linePointAmt : 0;
			    nextX = a.bezierPoint(curvePts[0].x, curvePts[1].x, curvePts[2].x, curvePts[3].x, nextT);
			    nextY = a.bezierPoint(curvePts[0].y, curvePts[1].y, curvePts[2].y, curvePts[3].y, nextT);
			    if(debug){a.stroke(255, Math.random()*100 + 50)};
				
			    // create a new point
			    bezP = pjs.addParticle(pointX, pointY);
			    bezPts[i] = bezP;
		      
			    rayPoint = bezPts[i];
			    r = new Ray(rays.size(), rayPoint, webCenter, spacingNoise);
			    rays.add(r);
		      
			    if (i>0)
			    {
			      if(debug){pjs.ellipse(pointX, pointY, 4, 4);}
			      this.rayPoints.push(bezP);
			    }*/
			}
			
			// go through the points and make strokes
			
			for (i=0; i<this.rayPoints.length; i+=1)
			//for (i=0; i<linePointAmt-1; i+=1)
			{
				// Finds the 1st point. Either the startPt or the first of the curve
				p = (i === 0) ? this.startPoint : this.rayPoints[i];
				
				// Finds the next point. Either the last point or the next in curve;
				
				
				
				
				// THIS IS THE PROBLEM AREA: NEED TO FIGURE OUT HOW TO SHOW THIS LINE
				
				nextP = (i < this.rayPoints.length-1) ? this.rayPoints[i+1] : this.nextPoint;
				
				dx = p.x - nextP.x;
				dy = p.y - nextP.y;
				lineDist = Math.sqrt(dx*dx + dy*dy);
				
				// lines between bezier points
				addStrand(p, nextP);
			}
			//pjs.makeSpring(bezPts[linePointAmt-1], this.nextPoint);
			//console.log(this.rayPoints[linePointAmt-2]);
			//addStrand(this.rayPoints[linePointAmt-2], this.nextPoint);
			
		};
    


		Anchor.prototype.defineSourceLines = function()
		{
		    var p, randomNum, rAnchor, rRay, pDist, i;
		
		    // for the random line points, draw a line from that to a random ray point
		    for (i=1; i<this.randomLinePoints.length-1; i+=1)
		    {
			p = this.randomLinePoints[i];
			
			randomNum = (Math.round(Math.random()-1));
			randomNum += this.myOrder;
		  
			if (randomNum < 0) { randomNum += anchors.size(); }
			if (randomNum >= anchors.size()) { randomNum = 0; }
	      
			rAnchor = anchors.get(randomNum);
			if (rAnchor.rayPoints.length < 2) { return; }
			rRay = rAnchor.rayPoints[Math.round(Math.random()*(rAnchor.rayPoints.length-2) + 1)];
			pDist = pjs.getPartDist(p, rRay);
		      
			pjs.makeSpring(p, rRay, pDist);
		    }
		};
		
		
		
		
		
		
		/**************************************************
		
				       RAY
		
		**************************************************/
	   
	       function Ray(theOrder, theStartPoint, theEndPoint, theSNoise)
	       {
		   var dx, dy, len, avgRad, pointSpacing, i, p, someNoise;
		   
		   this.startPt = new P(theStartPoint.x, theStartPoint.y);	// start point of the connecting line
		   this.endPt = new P(theEndPoint.x, theEndPoint.y);
		   this.strandLength = undefined;						// the length of strand from the web center
		   this.points = [];							// array of points along the ray line
		   this.myOrder = theOrder;						// the order of the ray around the web            
		   this.myAngle = undefined;						// the angle of the current ray
		   this.spacingNoise = theSNoise;						// noise for the placement of the points along the ray.
		   this.rayPointAmt = barPointAmt;						// amount of points along the array
		   this.startPoint = theStartPoint;
		   this.nextPoint = theEndPoint;
		   this.strands = undefined;
		   this.rayPoints = [];							// list of points that will make up the ray
		
			//console.log("this.rayPointAmt " + barPointAmt);
	       
		   // Find the length and angle of current and next line
		   dx = this.startPt.x - this.endPt.x;
		   dy = this.startPt.y - this.endPt.y;
		   this.myAngle = Math.atan2(dy, dx);
		   
		   len = Math.sqrt((dx*dx) + (dy*dy));
		  
	       
		   // Get the length of the strand. If the strand is longer than the average strand length, then use 
		   // that as the factor for getting the number and placement of points along the ray.
		   // Multiplying by a fraction will keep the points away form the edges of the strands.
		   avgRad = avgRadius;// * .9;
		   this.strandLength = (len < avgRad) ? len : avgRad;
	       
		   pointSpacing = (((this.strandLength-5) * 0.99) / barPointAmt);
	   
		   // find the positions of all the points that will go on the given ray
		   for (i=0; i<this.rayPointAmt; i+=1) {
		       someNoise = 1;//pjs.map(pjs.noise(spacingNoise), 0, 1, 0.75, 1.15);
		       p = new P(webCenter.x + Math.cos(this.myAngle)*(i*pointSpacing * someNoise), webCenter.y + Math.sin(this.myAngle)*(i*pointSpacing * someNoise));
		       this.points.push(p);
		       spacingNoise += 0.2;
		   }
	       }
	   
	   
	   
	       Ray.prototype.make = function()
	       {
			//console.log("ray make: " + this.myOrder, rays.length);
		   var radialNoise, i, randomChance, p, n, nextStrand, nextAngle, dx, dy, pointDist, thisPoint, startAngle, startPoint, strandLen;
		   // A thinner and less opaque line gives the sense of depth of a strand
		   radialNoise = Math.random()*100;
		   strands = new Array();
		   
		   // add the initail points to the points array so that they at least connect if nothing else
		   this.addRayPoint(this.startPoint);
		   this.addRayPoint(this.nextPoint);
			
			//console.log(this.rayPointAmt);
			for (i=1; i<this.rayPointAmt; i+=1) {
			
		       
			// randomly DON'T draw a line
			randomChance = Math.round(Math.random()*20);
			//randomChance = 1;
			if (randomChance === 0 || randomChance === 19 || randomChance === 18) { continue; }
			p = this.points[i];
			//n = Math.noise(radialNoise)*10;
			n = 10;
			
			// if not the last strand
			if (this.myOrder < rays.length-1) {
			    nextStrand = rays[this.myOrder+1];
			}
			else {
			    nextStrand = rays[0];
			}
	    
			nextAngle = nextStrand.myAngle;
			
			dx = p.x - webCenter.x;
			dy = p.y - webCenter.y;
			
			// Get a random distance to place the starting point at. it will be within a range above and 
			// below the original point. The further away from the center, the more variation it can have
			pointDist = this.getRandomPoint(dx, dy, i * 0.2, this.strandLength);
			thisPoint = addParticle(webCenter.x + Math.cos(this.myAngle) * pointDist, webCenter.y + Math.sin(this.myAngle) * pointDist);
			
			pointDist = this.getRandomPoint(dx, dy, i * 0.2, nextStrand.strandLength);
			
			// draw y shape between rays instead of straight line
			if (randomChance === 1)// || randomChance == 15 || randomChance == 16)
			{
			    this.drawYShape(p, thisPoint, nextAngle, nextStrand, pointDist);
			}
			else
			{
			    this.drawStrand(thisPoint, nextAngle, nextStrand, pointDist);
			}
			
			
			// draw another line from the point
			if (randomChance === 2) 
			{
			    pointDist = this.getRandomPoint(dx, dy, i * 0.8, nextStrand.strandLength);
			    this.drawStrand(thisPoint, nextAngle, nextStrand, pointDist);
			}
		  
		  
			// draws a much longer line from the start point (which can be from either side.)
			else if (randomChance === 3)
			{
			    startAngle = (Math.round(Math.random()) === 0) ? nextAngle : this.myAngle;
			    
			    if (startAngle === nextAngle)
			    {
				startPoint = thisPoint;
				strandLen = nextStrand.strandLength;
				pointDist = this.getRandomPoint(dx, dy, i*Math.random()*4 + 6, strandLen);
				this.drawStrand(startPoint, startAngle, nextStrand, pointDist, true);
			    }
			    else
			    {    
				startPoint = thisPoint;
				strandLen = nextStrand.strandLength;
				pointDist = this.getRandomPoint(dx, dy, i*Math.random()* -4 - 6, strandLen);
				this.drawStrand(startPoint, nextAngle, nextStrand, pointDist, true);
			    }
			}
			radialNoise += 0.1;
		    }
		};
	   
	       
	       Ray.prototype.drawYShape = function(p, thisPoint, nextAngle, nextStrand, pointDist)
	       {
		   var pointDev, startAngle, nextPointA, nextPointB, difAngle, randDif, partialPoint, startPoint;
		   // find extra points for "y" shape
		   pointDev = Math.random()*3 + 2;
		   startAngle = (Math.round(Math.random()) === 0) ? nextAngle : this.myAngle;
			   
		   nextPointA = addParticle(webCenter.x + Math.cos(startAngle) * (pointDist-pointDev), webCenter.y + Math.sin(startAngle) * (pointDist-pointDev));
		   
		   pointDev = Math.random()*3 + 2;
		   nextPointB = addParticle(webCenter.x + Math.cos(startAngle) * (pointDist+pointDev), webCenter.y + Math.sin(startAngle) * (pointDist+pointDev));
		   
		   // find partial way point
		   difAngle = (startAngle === nextAngle) ? this.myAngle - nextAngle : nextAngle - this.myAngle;
		   if (difAngle<-1) { difAngle+=Math.TWO_PI; }
		   if (difAngle>1) { difAngle-=Math.TWO_PI; }
		   randDif = Math.random() * difAngle;
		   partialPoint = addParticle(webCenter.x + Math.cos(startAngle + randDif) * pointDist, webCenter.y + Math.sin(startAngle + randDif) * pointDist);
		   
		   if (startAngle === nextAngle)
		   {
		       startPoint = thisPoint;
		       this.addRayPoint(startPoint);
		       
		       nextStrand.addRayPoint(nextPointA);
		       nextStrand.addRayPoint(nextPointB);
		   }
		   else {
		       startPoint = addParticle(webCenter.x + Math.cos(nextAngle) * pointDist, webCenter.y + Math.sin(nextAngle) * pointDist);
		       nextStrand.addRayPoint(startPoint);
		       this.addRayPoint(nextPointA);
		       this.addRayPoint(nextPointB);
		   }
		   
			addStrand(startPoint, partialPoint);
			addStrand(partialPoint, nextPointA);
			addStrand(partialPoint, nextPointB);
		   
		   /*if(debug){
		       pjs.line(startPoint.x, startPoint.y, partialPoint.x, partialPoint.y);
		       pjs.line(partialPoint.x, partialPoint.y, nextPointA.x, nextPointA.y);
		       pjs.line(partialPoint.x, partialPoint.y, nextPointB.x, nextPointB.y);
		   }*/
	       };
	       
	       
	       
	       Ray.prototype.drawStrand = function(thisPoint, nextAngle, nextStrand, pointDist, fromOppositeSide)
	       {
			//console.log("draw Strand");
		   var nextPoint, lineLen;
		   
		   nextPoint = addParticle(webCenter.x + Math.cos(nextAngle) * pointDist, webCenter.y + Math.sin(nextAngle) * pointDist);
		   // draws a normal single connector line
		   lineLen = getPartDist(thisPoint, nextPoint);
		   if (lineLen > 0) {
			   this.addRayPoint(thisPoint);
			   nextStrand.addRayPoint(nextPoint);
			   addStrand(thisPoint, nextPoint);
		   }
	       };
	       
	       
	   
	       Ray.prototype.defineRayPoints = function()
	       {
			console.log("define ray points");
			var dist1, dist2, i, p1, p2, len, s;
			// sort the points from closest to furthest from the web center
			function sortDistance(a,b){
			    dist1 = getPartDist(webCenter, a);
			    dist2 = getPartDist(webCenter, b);
		
			    return Math.round(dist1 - dist2);
			}
			this.rayPoints.sort(sortDistance);
		   
			// go through the points and create a strand and define the spring
			for (i=1; i<this.rayPoints.length; i+=1)
			{
			    p1 = this.rayPoints[i];
			    p2 = this.rayPoints[i-1];
			    len = getPartDist(p1, p2);
			    
			    
				addStrand(p1, p2);	
			    /*if(debug){pjs.ellipse(p1.x, p1.y, 3, 3);}
			    pjs.stroke(0, 255);
			    */
			    //s = physics.springs[physics.springs.length-1];
			    //if(debug){pjs.line(s.a.x, s.a.y, s.b.x, s.b.y);}
			}
	       };
	       
	       
	       Ray.prototype.boolToInt = function(value) {
		   var intVal = (value) ? 1 : 0;
		   return intVal;
	       };
	       
	       
	       Ray.prototype.getRandomPoint = function(dx, dy, range, maxLength)
	       {
		   var pointDist = Math.sqrt((dx*dx) + (dy*dy)) + Math.random()*(range*2) - range;//-range, range);
		   // make sure they are not connecting to points that don't exist
		   pointDist = (pointDist > maxLength) ? maxLength : pointDist;
		   return pointDist;
	       };
	       
	   
	       // once all the rays are defined, the ray points will be defined. Then the line and spring can be added
	       Ray.prototype.addRayPoint = function(p) {
		   // check to make sure we don't add any dupe points
		   for(var i=0; i < this.rayPoints.length; i+=1){
		       if(this.rayPoints[i].x === p.x && this.rayPoints[i].y === p.y){
			   return;
		       }
		   }
		   this.rayPoints.push(p);
		   //pjs.stroke(0, 0, 255);
		   //pjs.noFill();
	       };
	       
	       
	       
	       getPartDist = function(pt1, pt2)
		{
		    var dx, dy, len;
		    dx = (pt1.x - pt2.x);
		    dy = (pt1.y - pt2.y);
		    len = Math.sqrt((dx*dx) + (dy*dy));
		    return len;
		};
		
		addStrand = function(pt1, pt2){
			//console.log("add strand: " + pt1.x);
			//console.log("add strand: " + pt2.x);
			console.log(Math.floor(((Math.random()*0.5) + 0.5)*10)/10);
			//a.strokeStyle = 'rgba(150, 150, 150, ' + (Math.floor(((Math.random()*0.5) + 0.5)*10)/10) + ')';
			a.strokeStyle = 'rgba(0, 0, 0, ' + ((Math.random()*0.5) + 0.3) + ')'; 
			a.beginPath();
			a.moveTo(pt1.x, pt1.y);
			a.lineTo(pt2.x, pt2.y);
			a.stroke();
			
		}
		
		    
		drawWeb();
		
	}
	
	
	

}


web();


// end of submission //
		</script>
	</body>
</html>
