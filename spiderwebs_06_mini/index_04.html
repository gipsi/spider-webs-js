
<!doctype html>
<html>
	<head>
		<title>JS1k, 1k demo submission [ID]</title>
		<meta charset="utf-8" />
	</head>
	<body>
		<canvas id="c"></canvas>
		<script>
			var b = document.body;
			var c = document.getElementsByTagName('canvas')[0];
			var a = c.getContext('2d');
			document.body.clientWidth; // fix bug in webkit: http://qfox.nl/weblog/218
		</script>
		<script>
	// start of submission //
	c.width = 800;
	c.height = 800;
	with(m = Math) C = cos, S = sin, Rn = random, F = floor, Ab = abs, Rd = round, Sq = sqrt, Pi = PI;
	//with(this)
	
	function P(x,y){this.x = x;this.y = y;}
	
	function web(){
		// define the anchor points of the heart shape
		var rays, rSpc, pNum, cX, cY, rBase, barPtAmt, pts, strands, TWO_PI, PI_2, webCtr, avgR;
		
		pNum = F(Rn()*3)+4;
		rSpc = (Rn() * 30) + 40;
		barPtAmt = (Rn() * 10) + 15;
		pts = [];
		strands = [];
		cX = c.width/2;
		cY = c.height/2;
		rBase = 200;
		TWO_PI = Pi*2;
		PI_2 = Pi/2;
		
		// draw lines along the points for each letter
		
		drawWeb = function(){
			strands = [];
			rays = [];
			// draw everything
		        this.mkAnchPts();
			this.makeRays();
		};
		
		
		mkAnchPts = function(){
			var anchPts, angleDif, maxX, minX, maxY, minY, rSum, i, angle, r, pX, pY, p, startPt, endPt, anchor;
			anchPts = [];
			angleDif = TWO_PI/pNum;
			maxX = 0;
			minX = c.width;
			maxY = 0;
			minY = c.height;
			rSum = 0;
			
			p = new P(100, 100);

			for (i=0; i<pNum; i+=1) {
				angle = (i * angleDif);
				r = rBase * (Rn() + 0.5);
				rSum += r;
				pX = cX + C(angle) * r;
				pY = cY + S(angle) * r;
				p = this.addPt(pX, pY);
			      
				maxX = (pX > maxX) ? pX : maxX;
				minX = (pX < minX) ? pX : minX;
				maxY = (pY > maxY) ? pY : maxY;
				minY = (pY < minY) ? pY : minY;
			    
				anchPts.push(p);
			}
    
			avgR = rSum / pNum;
			webCtr = this.addPt(minX + (maxX - minX)/2, minY + (maxY - minY)/2);
		      
			// create the anchor strands from the points
			this.anchors = [];
			for (i=0; i<anchPts.length; i+=1) {
			  startPt = anchPts[i];
			  endPt = (i<anchPts.length-1) ? anchPts[i+1] : anchPts[0];
			  anchor = new A(startPt, endPt);
				
				// Draw edges
				var myAngle = getAngle(startPt, webCtr);
				var opAngle = PI_2 - ((myAngle < 0) ? myAngle + TWO_PI: myAngle);
				var sideDistX = (startPt.x < c.width/2) ? -startPt.x:c.width - startPt.x;
				var sideDistY = (startPt.y < c.height/2) ? -startPt.y : c.height - startPt.y;
		
				opRx = sideDistX/S(opAngle);
				opRy = sideDistY/C(opAngle);
				opR =  (Ab(opRx)<Ab(opRy)) ? opRx : opRy;
		
				edgeP = addPt(startPt.x +  C(myAngle) * (opR), startPt.y + S(myAngle) * (opR));
				addS(startPt, edgeP);
			  
			  
			  anchor.makePoints();
			  this.anchors.push(anchor);
			}
		};
		
    
		makeRays = function() {
			var i, r;
			for (i=0; i<rays.length; i+=1)
			{
			  r = rays[i];
			  r.make();
			}
		      
			for (i=0; i<rays.length; i+=1)
			{
			  r = rays[i];
			  r.dfnRPts();
			}
		};
		
		
		addPt = function(xPos,yPos)
		{
			var pt, i;
			// first check to see if a particle of the same position is already there. Return it if so.
			for(i=0; i<pts.length; i+=2){
			    if(pts[i].x === xPos && pts[i].y === yPos){
				return pts[i];
			    }
			}
			pt = new P(xPos, yPos);
			pts.push(pt);
			
			return pt;
		};
		
		
		
		/****		ANCHOR		***/

		function A(p1, p2) {
			this.startPt = new P(p1.x, p1.y);	// start point of the connecting line
			this.endPt = new P(p2.x, p2.y);		// end point of the connecting line
			this.rayPoints = [];							// points to connect the ray
			    
			// find the angle of the anchor point (in relation to the web center)
			this.myAngle = getAngle(p1, webCtr);
		};


		/*
		// draw the lines from the anchor points to the border
		A.prototype.drEdges = function()
		{
			var opAngle, sideDistX, sideDistY, opRx, opRy, opR, edgeP;
		    
			opAngle = PI_2 - ((this.myAngle < 0) ? this.myAngle + TWO_PI: this.myAngle);
			sideDistX = (this.startPt.x < c.width/2) ? -this.startPt.x:c.width - this.startPt.x;
			sideDistY = (this.startPt.y < c.height/2) ? -this.startPt.y : c.height - this.startPt.y;
		
			opRx = sideDistX/S(opAngle);
			opRy = sideDistY/C(opAngle);
			opR =  (Ab(opRx)<Ab(opRy)) ? opRx : opRy;
		
			edgeP = addPt(this.startPt.x +  C(this.myAngle) * (opR), this.startPt.y + S(this.myAngle) * (opR));
			addS(this.startPt, edgeP);
		};*/

 

		A.prototype.makePoints = function()
		{
			var lineDist, lineAngle, lnPtAmt, lnPtDist, i, ptX, ptY, r, p, nextP, rayP;
		    	lineDist = getPtDist(this.startPt, this.endPt);
			lineAngle = getAngle(this.endPt, this.startPt);
			
			
			// ensure that there are at least 2 points to go between
			// If only 1, it will fail
			pointDistFactor = 0;
			do {
			  lnPtAmt = F(lineDist/(rSpc - pointDistFactor));
			  pointDistFactor += 1;
			}
			while (lnPtAmt<2);
			
			lnPtDist = lineDist/lnPtAmt;
			
			// Now draw the lines between bezier points
			this.rayPoints = [];
			
			// make points between the start and end
			for (i=0; i<lnPtAmt; i+=1)
			{
				ptX = this.startPt.x + C(lineAngle) * (i*lnPtDist);
				ptY = this.startPt.y + S(lineAngle) * (i*lnPtDist);
				addPt(ptX, ptY);
			
				rayP = addPt(ptX, ptY);
				r = new R(rays.length, rayP, webCtr);
				rays.push(r);
				
				this.rayPoints.push(rayP);
				
				if(i>0){
					p = this.rayPoints[i];
					nextP = this.rayPoints[i-1];
					addS(p, nextP);
				}
			}
			// connect to the next strand's point
			addS(p, this.endPt);
		};
    
		
		/*******	       RAY		*******/
	   
	       function R(order, startPt, endPt)
	       {
		   var len, ptSpc, i, p;
		   
		   this.strndLen = undefined;						// the length of strand from the web center
		   this.points = [];							// array of points along the ray line
		   this.myOrder = order;						// the order of the ray around the web
		   this.startPt = startPt;
		   this.nextPt = endPt;
		   this.strands = undefined;
		   this.rayPoints = [];							// list of points that will make up the ray
		
		   // Find the length and angle of current and next line
		   this.myAngle = getAngle(startPt, endPt);				// the angle of the current ray
		   len = getPtDist(startPt, endPt);
		  
	       
		   // Get the length of the strand. If the strand is longer than the average strand length, then use 
		   // that as the factor for getting the number and placement of points along the ray.
		   // Multiplying by a fraction will keep the points away form the edges of the strands.
		   this.strndLen = (len < avgR) ? len : avgR;
	       
		   ptSpc = (((this.strndLen-5) * 0.99) / barPtAmt);
	   
		   // find the positions of all the points that will go on the given ray
		   for (i=0; i<barPtAmt; i+=1) {
		       p = new P(webCtr.x + C(this.myAngle)*(i*ptSpc), webCtr.y + S(this.myAngle)*(i*ptSpc));
		       this.points.push(p);
		   }
	       };
	   
	   
	   
	       R.prototype.make = function()
	       {
			var i, rndm, p, nextStrand, nextAngle, dx, dy, pointDist, thisPoint, startAngle, startPt, strandLen;
			// A thinner and less opaque line gives the sense of depth of a strand
			strands = [];
		   
			// add the initail points to the points array so that they at least connect if nothing else
			this.addRayPt(this.startPt);
			this.addRayPt(this.nextPt);
			
			for (i=1; i<barPtAmt; i+=1) {
				// randomly DON'T draw a line
				rndm = Rd(Rn()*20);
			
				if (rndm === 0 || rndm === 19 || rndm === 18) { continue; }
				p = this.points[i];
			
				// if not the last strand
				if (this.myOrder < rays.length-1) {
					nextStrand = rays[this.myOrder+1];
				}
				else {
					nextStrand = rays[0];
				}
	    
				nextAngle = nextStrand.myAngle;
				
				dx = p.x - webCtr.x;
				dy = p.y - webCtr.y;
				
				// Get a random distance to place the starting point at. it will be within a range above and 
				// below the original point. The further away from the center, the more variation it can have
				pointDist = getRandPt(dx, dy, i * 0.2, this.strndLen);
				thisPoint = addPt(webCtr.x + C(this.myAngle) * pointDist, webCtr.y + S(this.myAngle) * pointDist);
				
				pointDist = getRandPt(dx, dy, i * 0.2, nextStrand.strndLen);
			
				// draw y shape between rays instead of straight line
				/*if (rndm === 1){// || rndm == 15 || rndm == 16){
				    this.drawYShape(p, thisPoint, nextAngle, nextStrand, pointDist);
				}else{
				    this.drawStrand(thisPoint, nextAngle, nextStrand, pointDist);
				}*/
				this.drawStrand(thisPoint, nextAngle, nextStrand, pointDist);
			
			
				// draw another line from the point
				if (rndm === 2) {
				    pointDist = getRandPt(dx, dy, i * 0.8, nextStrand.strndLen);
				    this.drawStrand(thisPoint, nextAngle, nextStrand, pointDist);
				}
		  
		  
				// draws a much longer line from the start point (which can be from either side.)
				else if (rndm === 3){
					startAngle = (Rd(Rn()) === 0) ? nextAngle : this.myAngle;
				    
					if (startAngle === nextAngle){
						startPt = thisPoint;
						strandLen = nextStrand.strndLen;
						pointDist = getRandPt(dx, dy, i*Rn()*4 + 6, strandLen);
						this.drawStrand(startPt, startAngle, nextStrand, pointDist, true);
					}else{    
						startPt = thisPoint;
						strandLen = nextStrand.strndLen;
						pointDist = getRandPt(dx, dy, i*Rn()* -4 - 6, strandLen);
						this.drawStrand(startPt, nextAngle, nextStrand, pointDist, true);
					}
				}
			}
		};
	   
		/*    
		R.prototype.drawYShape = function(p, thisPoint, nextAngle, nextStrand, pointDist){
			var pointDev, startAngle, nextPointA, nextPointB, difAngle, randDif, partialPoint, startPoint;
			// find extra points for "y" shape
			pointDev = Rn()*3 + 2;
			startAngle = (Rd(Rn()) === 0) ? nextAngle : this.myAngle;
				   
			nextPointA = addPt(webCtr.x + C(startAngle) * (pointDist-pointDev), webCtr.y + S(startAngle) * (pointDist-pointDev));
		   
			pointDev = Rn()*3 + 2;
			nextPointB = addPt(webCtr.x + C(startAngle) * (pointDist+pointDev), webCtr.y + S(startAngle) * (pointDist+pointDev));
		   
			// find partial way point
			difAngle = (startAngle === nextAngle) ? this.myAngle - nextAngle : nextAngle - this.myAngle;
			if (difAngle<-1) { difAngle+=TWO_PI; }
			if (difAngle>1) { difAngle-=TWO_PI; }
			randDif = Rn() * difAngle;
			partialPoint = addPt(webCtr.x + C(startAngle + randDif) * pointDist, webCtr.y + S(startAngle + randDif) * pointDist);
		   
			if (startAngle === nextAngle){
				startPoint = thisPoint;
				this.addRayPt(startPoint);    
				nextStrand.addRayPt(nextPointA);
				nextStrand.addRayPt(nextPointB);
			} else {
				startPoint = addPt(webCtr.x + C(nextAngle) * pointDist, webCtr.y + S(nextAngle) * pointDist);
				nextStrand.addRayPt(startPoint);
				this.addRayPt(nextPointA);
				this.addRayPt(nextPointB);
			}
			addS(startPoint, partialPoint);
			addS(partialPoint, nextPointA);
			addS(partialPoint, nextPointB);
		};*/
	       
	       
		R.prototype.drawStrand = function(thisPoint, nextAngle, nextStrand, pointDist, fromOppositeSide){
			var nextPoint, lineLen;
			
			nextPoint = addPt(webCtr.x + C(nextAngle) * pointDist, webCtr.y + S(nextAngle) * pointDist);
			// draws a normal single connector line
			lineLen = getPtDist(thisPoint, nextPoint);
			if (lineLen > 0) {
				this.addRayPt(thisPoint);
				nextStrand.addRayPt(nextPoint);
				addS(thisPoint, nextPoint);
			}
		};
	       
	       
	   
	       R.prototype.dfnRPts = function()
	       {
			var dist1, dist2, i, p1, p2, len;
			// sort the points from closest to furthest from the web center
			function sortDistance(a,b){
			    dist1 = getPtDist(webCtr, a);
			    dist2 = getPtDist(webCtr, b);
			    return Rd(dist1 - dist2);
			}
			this.rayPoints.sort(sortDistance);
		   
			// go through the points and create a strand and define the spring
			for (i=1; i<this.rayPoints.length; i+=1)
			{
				p1 = this.rayPoints[i];
				p2 = this.rayPoints[i-1];
				len = getPtDist(p1, p2);
				addS(p1, p2);
			}
	       };
	       
	       
	       
	       getRandPt = function(dx, dy, range, maxL)
	       {
		   var ptDist = Sq((dx*dx) + (dy*dy)) + Rn()*(range*2) - range;//-range, range);
		   // make sure they are not connecting to points that don't exist
		   ptDist = (ptDist > maxL) ? maxL : ptDist;
		   return ptDist;
	       };
	       
	   
	       // once all the rays are defined, the ray points will be defined. Then the line and spring can be added
	       R.prototype.addRayPt = function(p) {
		   // check to make sure we don't add any dupe points
		   for(var i=0; i < this.rayPoints.length; i+=1){
		       if(this.rayPoints[i].x === p.x && this.rayPoints[i].y === p.y){
			   return;
		       }
		   }
		   this.rayPoints.push(p);
	       };
	       
	       
	       
		getPtDist = function(pt1, pt2){
		    var dx, dy, len;
		    dx = (pt1.x - pt2.x);
		    dy = (pt1.y - pt2.y);
		    len = Sq((dx*dx) + (dy*dy));
		    return len;
		};
		
		getAngle = function(p1, p2){
			var dx, dy;
			dx = (p1.x - p2.x);
			dy = (p1.y - p2.y);
			return Math.atan2(dy, dx);
		};
		
		addS = function(pt1, pt2){
			a.strokeStyle = 'rgba(0, 0, 0, ' + ((Rn()*0.5) + 0.3) + ')'; 
			a.beginPath();
			a.moveTo(pt1.x, pt1.y);
			a.lineTo(pt2.x, pt2.y);
			a.stroke();	
		};
		drawWeb();
}
web();
// end of submission //
		</script>
	</body>
</html>
