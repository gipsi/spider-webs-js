
<!doctype html>
<html>
	<head>
		<title>JS1k, 1k demo submission [ID]</title>
		<meta charset="utf-8" />
	</head>
	<body>
		<canvas id="c"></canvas>
		<script>
			var b = document.body;
			var c = document.getElementsByTagName('canvas')[0];
			var a = c.getContext('2d');
			document.body.clientWidth; // fix bug in webkit: http://qfox.nl/weblog/218
		</script>
		
		<script>
	// start of submission //
	c.width = 800;
	c.height = 800;
	//with(m = Math) C = cos, S = sin, Rn = random, F = floor, Rd = round, Sq = sqrt, Pi = PI, T = atan2;
	//with(this)
	
	function P(x,y){this.x = x;this.y = y;}
	
	function w(){
		// define the anchor points of the heart shape
		var rays, mkBars, getPtDist, getA, drwStr, getRPt, addS, aPts, rSpc= (Math.random() * 30) + 30, pNum= (Math.random()*3)+ 4, cX=c.width/2, cY=c.height/2, barPtAmt=(Math.random() * 10) + 15, TWO_PI=Math.PI*2, webCtr;
		
		
		
		/*******	       RAY		*******/
	   
	       function R(p1, p2)
	       {
			this.pts = [];							// array of points along the ray line
			this.rPts = [];							// list of points that will make up the ray
			this.p1 = p1;
			
			// Find the length and angle of current and next line
			this.myA = getA(p1, p2);				// the angle of the current ray
			var len=getPtDist(p1, p2);  
			
			// Get the length of the strand. If the strand is longer than the average strand length, then use 
			// that as the factor for getting the number and placement of points along the ray.
			// Multiplying by a fraction will keep the points away from the edges of the strands.
			this.sLen = (len < 200) ? len : 200;
	       }
	   
	   
	   
	       
		drwStr = function(r, pt, nextAngle, pointDist){
			var nextPoint=new P(webCtr.x + Math.cos(nextAngle) * pointDist, webCtr.y + Math.sin(nextAngle) * pointDist);
			// draws a normal single connector line
			if (getPtDist(pt, nextPoint)) {
				r.rPts.push(pt);
				addS(pt, nextPoint);
			}
		};
	       
	       
	       
	       
	       getRPt = function(dx, dy, range, maxL)
	       {
		   var ptDist = Math.sqrt((dx*dx) + (dy*dy)) + Math.random()*(range*2) - range;//-range, range);
		   // make sure they are not connecting to points that don't exist
		   return (ptDist > maxL) ? maxL : ptDist;
	       };
	       
	   
	       
		getPtDist = function(p1, p2){
			
		    var dx=(p1.x - p2.x), dy=(p1.y - p2.y);
		    return Math.sqrt((dx*dx) + (dy*dy));
		};
		
		getA = function(p1, p2){
			return Math.atan2((p1.y - p2.y), (p1.x - p2.x));
		};
		
		addS = function(p1, p2){
			
			a.strokeStyle = 'rgba(0, 0, 0, ' + ((Math.random()*0.6) + 0.25) + ')'; 
			a.beginPath();
			a.moveTo(p1.x, p1.y);
			a.lineTo(p2.x, p2.y);
			a.stroke();	
		};
		
		
		//pNum = 4;
		//rSpc = 70;
		//barPtAmt = 3;
		
		aPts = function(){
			
			var anchPts=[], i, j, angle, r, pX, pY, p, startPt, endPt, myA, lineDist, lineAngle, lnPtAmt, lnPtDist, ptX, ptY, nextP, rayP, rPts, edgeP;
			//strands = [];
			rays = [];
			webCtr = new P(400, 400);
			
			// for each point created, create an anchor point
			for (i=0; i<pNum; i++) {
				
				angle = i * (TWO_PI/pNum);
				r = 200 * (Math.random() + 0.5);
				pX = cX + Math.cos(angle) * r;
				pY = cY + Math.sin(angle) * r;
				p = new P(pX, pY);

			      
				anchPts.push(p);
				
				startPt = (i>0) ? anchPts[i-1] : anchPts[0];
				endPt = (i<pNum-1) ? p : anchPts[0];
				
				// Draw edges
				myA = getA(startPt, webCtr);
		
				edgeP = new P(startPt.x +  Math.cos(myA) * 500, startPt.y + Math.sin(myA) * 500);
				addS(startPt, edgeP);
			  
				// Make points
				//var lineDist, lineAngle, lnPtAmt, lnPtDist, i, ptX, ptY, r, p, nextP, rayP;
				lineDist = getPtDist(startPt, endPt);
				lineAngle = getA(endPt, startPt);
			
				
				lnPtAmt = Math.floor(lineDist/rSpc);
				lnPtDist = lineDist/lnPtAmt;
				
				
				rPts = [];
				
				// make points between the anchors, I call them rays (since they come from a center point)
				
				for (j=0; j<lnPtAmt; j++)
				{
					
					ptX = startPt.x + Math.cos(lineAngle) * (j*lnPtDist);
					ptY = startPt.y + Math.sin(lineAngle) * (j*lnPtDist);
					//	new P(ptX, ptY);
				
					rayP = new P(ptX, ptY);
					rPts.push(rayP);
					
					r = new R(rayP, webCtr);
					rays.push(r);

					p = rPts[j];
					addS(p, webCtr);
					
					if(rays.length>1) {
						mkBars(rays.length-1);
					}

					if(j>0){
						
						nextP = rPts[j-1];
						addS(rayP, nextP);
						r.rPts.push(p);
						r.rPts.push(nextP);
					}
				}
				
				// connect to the next strand's point
				addS(p, endPt);
				
					
			}
			mkBars(0);
		};
		
		
		
		mkBars = function(rayNum){
			var ray = rays[rayNum], rndm, barPt, k, nextAngle, nextStrand, thisPoint, pointDist, dx, dy;
			
			
	       
				ptSpc = ((ray.sLen-5) * 0.99) / barPtAmt;
			
			for (k=0; k<Number(barPtAmt); k++) {
				// randomly DON'T draw a line
				rndm = Math.round(Math.random()*5);
					
				if (rndm === 1) { continue; }
				//barPt = ray.pts[k];
				
				
		
				// find the positions of all the pts that will go on the given ray
			
				barPt = new P(webCtr.x + Math.cos(ray.myA)*(k*ptSpc), webCtr.y + Math.sin(ray.myA)*(k*ptSpc));
				/*console.log(barPt);
				
				a.beginPath();
				a.arc(barPt.x, barPt.y, 2, 0, TWO_PI);
				a.fillStyle = "#ff0000";
				a.fill();*/
				
				// if not the last strand
				
				nextStrand = (rayNum > 0) ? rays[rayNum - 1] : rays[rays.length-1];
				
				nextAngle = nextStrand.myA;
				
				if(k>0){
					
					dx=(barPt.x - webCtr.x), dy=(barPt.y - webCtr.y);
					// Get a random distance to place the starting point at. it will be within a range above and 
					// below the original point. The further away from the center, the more variation it can have
					pointDist = getRPt(dx, dy, k * 0.2, ray.sLen);
					thisPoint = new P(webCtr.x + Math.cos(ray.myA) * pointDist, webCtr.y + Math.sin(ray.myA) * pointDist);
					
					
					pointDist = getRPt(dx, dy, k * 0.2, nextStrand.sLen);
					
					drwStr(ray, thisPoint, nextAngle, pointDist);
			
				}
			}
		};
		
		
		
		
		
		aPts();
		//mkR();
	}
w();
// end of submission //
		</script>
	</body>
</html>
